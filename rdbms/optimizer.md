## Optimizer

### Optimizer 란? [출처](https://coding-factory.tistory.com/743)
- 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DMBS 엔진
- 실행 요청된 SQL에 대해 여러가지 실행계획을 세우고, 시스템 통계정보를 활용하여 각 실행계획의 예상 비용을 산정한 후 각 실행 계획을 비교해서 최고 효율을 가지고 있는 계획에 따라 쿼리 수행

### 규칙 기반 옵티마이저 (RBO)
- 실행 속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위에 따라 실행
- 우선순위를 잘 알면 효율적인 쿼리문 작성에 도움이 된다
- 실행계획을 유도할 수 있는 Hint와 Hash join의 경우는 규칙기반에서 작동하지 않는다
#### 규칙 우선순위
1.	 ROWID를 사용한 단일 행인 경우
2.	 클러스터 조인에 의한 단일 행인 경우
3.	 유일하거나 기본키(Primary Key)를 가진 해시 클러스터 키에 의한 단일 행인 경우
4.	 유일하거나 기본키(Primary Key)에 의한 단일 행인 경우
5.	 클러스터 조인인 경우
6.	 해시 클러스터 조인인 경우
7.	 인덱스 클러스터 키인 경우
8.	 복합 칼럼 인덱스인 경우
9.	 단일 칼럼 인덱스인 경우
10.	 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우
11.	 인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우
12.	 정렬-병합(Sort-Merge) 조인인 경우
13.	 인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우
14.	 인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우
15.	 전체 테이블을 스캔(FULL TABLE SCAN)하는 경우

### 비용 기반 옵티마이저
- 실행 계획 비용이 최소인 실행 계획 수행
- 최근에 많이 사용됨 (오라클 10 이후 버전부터는 비용기반만 사용)
- 규칙 기반에서 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계 정보와 시스템 통계 정보를 이용함
- 통계정보가 없는 경우, 효율이 떨어지므로 정확한 통계정보를 유지하는 것이 중요

#### 비용 기반 옵티마이저의 모드
- CHOOSE: 통계 정보를 가져올 수 있으면 비용기반, 그렇지 않다면 규칙 기반으로 작동
- FIRST_ROWS: 처리 결과 중 첫 건을 출력하는데 걸리는 시간을 최소화할 수 있는 실행 계획 수립
- FIRST_ROWS_n: sql의 실행 결과를 출력하는데 걸리는 응답속도를 최적화하는 모드
- ALL_ROWS: sql 실행 결과 전체를 빠르게 처리하는데 최적화 된 실행계획을 세우는 모드. 마지막으로 출력될 행까지 최소한의 자원을 사용하여 최대한 빨리 가져오게함 (오라클 10g 이후 버전 기본값)

### 옵티마이저 동작 방식
- Parser: SQL 문장 분석하여 문법 검사와 구성요소를 파악하고, 파싱해서 파싱 트리 생성
- Query Transformer: 파싱된 SQL을 보고 같은 결과를 도출하되, 좀 더 나은 실행계획을 갖는 SQL로 변환이 가능한지 판단하여 변환 작업 수행
- Estimator: 시스템 통계정보를 딕셔너리로부터 수집하여 sql을 실행할 때 소요되는 총 비용 계산
- Plan Generator: Estimator를 통해 계산된 값들을 토대로 후보군이 되는 실행계획 도출
- Row-Source Generator: 옵티마이저가 생성한 실행계획을 sql엔진이 실제 실행할 수 있는 코드나 프로시저 형태로 포맷팅
- SQL Engine: SQL 실행

### 옵티마이저 최적화 고려사항
#### 통계정보
- 비용기반 옵티마이저는 DBMS에서 제공하는 통계 정보에 의존함
- 통계정보를 지속적으로 갱신 해주는 것이 좋음 (자동, 수동 가능)
- DBMS_STATS 패키지를 사용해서 데이터베이스, 스키마 및 계정, 테이블 인덱스 단위로 구분하여 통계정보 수집 가능
##### 주요 통계 정보들
- 테이블:
  - 테이블의 전체 행 개수
  - 테이블이 차지하고 있는 전체 블록 개수
  - 테이블의 행들이 가지고 있는 평균길이
- 컬럼:
  - 컬럼값의 종류
  - 컬럼 내부 NULL값의 분포도
  - 컬럼 값의 평균길이
  - 컬럼 내부 데이터 분포의 추정치
- 인덱스:
  - LEAF BLOCK수: 데이터를 보관하는 블록 수 
  - LEVELS: 인덱스 트리의 LEVEL 정보
  - CLUSTERING FACTOR : 접근하고자 하는 데이터가 모여 있는 밀집도
- 시스템:
  - I/O 성능 및 사용률
  - CPU 성능 및 사용률

#### 고려사항
- 통계 정보만으로는 조건절에서 사용돤 조건을 만족하는 데이터의 양을 정확히 알 수 없으므로, 비용 계산 결과가 정확하지 않을 수 있다
- 비용산정 시 쿼리문 단독으로 실행된다고 가정하기에 여러 쿼리가 동시 실행되는 환경에서 실제 비용은 달라질 수 있다
- 히스토그램 버킷은 최대 254까지만 사용할 수 있어, 254개 이상의 값을 갖는 컬럼의 경우 비용 예측 결과가 정확하지 않을 수 있다
- 쿼리 튜닝 시 힌트같은 부가적인 장치를 통해 올바르게 작동될 수 있도록 유도하는 방법도 필요함